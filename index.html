<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A2 Technical English Quizzes</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a cleaner UI/UX */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; 
        }
        .container {
            max-width: 900px;
        }
        .question-label {
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        .question-label:hover {
            background-color: #f1f5f9; 
        }
        /* Style for radio buttons */
        input[type="radio"] {
            margin-right: 8px;
            accent-color: #3b82f6; 
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-green': '#10b981',
                        'secondary-blue': '#3b82f6',
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 sm:p-8">

    <div class="container mx-auto">
        <header class="text-center mb-10 p-6 bg-white rounded-xl shadow-lg">
            <h1 class="text-4xl font-extrabold text-secondary-blue">A2 Technical English Quizzes</h1>
            <p class="text-gray-600 mt-2 text-lg">40 Questions | Collaborative Voting (Simulated)</p>
            
            <div class="mt-4">
                <button onclick="window.resetAllData()" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white font-bold text-sm rounded-lg shadow-md transition duration-200">
                    Reset All Votes & Progress
                </button>
                <p class="text-xs text-gray-500 mt-1">Click here to clear all saved votes and progress (to start with 0 votes).</p>
            </div>
        </header>

        <div id="quiz-container">
            <!-- Dynamic quiz content will be rendered here -->
        </div>
        
        <footer class="text-center mt-10 p-4 text-gray-500 text-sm">
            <p>The blue border highlights the group's majority vote (your choice + simulated users).</p>
        </footer>
    </div>

    <script>
        // --- CONSTANTS ---
        const USER_ID = 'my-current-user'; // Unique ID for current user's vote
        const SIMULATED_USERS = ['sim1', 'sim2', 'sim3', 'sim4', 'sim5', 'sim6', 'sim7', 'sim8'];
        const TOTAL_VOTERS = 1 + SIMULATED_USERS.length; // 9 total votes (1 real + 8 simulated)
        
        // --- QUIZ DATA ---
        const tests = [
            // --- TEST 1: Websites and Technical Vocabulary ---
            {
                id: 'test1',
                title: 'Test 1: Websites and Technical Vocabulary üåê',
                description: 'Read the text and answer the questions one by one.',
                text: 
                    "A website is like a digital house or place on the Internet. It has many rooms, which we call pages. To visit this digital house, you need a special program called a **browser**, like Google Chrome or Apple Safari. When you first arrive, the main door is the **Homepage**, which is the first, main page you see.\n\n" +
                    "Every website has a unique location called a **URL** (Uniform Resource Locator), which is its full address. You type this address into the **Address Bar** in your browser. To interact with the page, you **click** your mouse or **tap** your screen to select things or buttons. If you want to put information into a search box, you **type** your words. When you want to move the page up or down to see more content, you **scroll**. When you select a button or an **icon** (a small picture that links to something), the page may need time to **load**. Sometimes, the connection is slow, and the page loads slowly.",
                questions: [
                    { q: "What is a website like?", options: ["A special computer program.", "A digital house or place on the Internet.", "A small picture that links to something."], correct: 1 },
                    { q: "What is a BROWSER?", options: ["The first, main page of a website.", "The full address of the website.", "A special program you open to find websites."], correct: 2 },
                    { q: "What is the HOMEPAGE?", options: ["The space where you type the URL.", "The first, main page of a website.", "A special program like Chrome or Safari."], correct: 1 },
                    { q: "The letters U.R.L. stand for what?", options: ["The full address of the website.", "The main page of a site.", "A special program to find websites."], correct: 0 },
                    { q: "If you click your mouse on a screen, what do you do?", options: ["To tap.", "To type.", "To click."], correct: 2 },
                    { q: "What do you use to move the page up and down?", options: ["To type.", "To scroll.", "To load."], correct: 1 },
                    { q: "I want to write my name in the search box. I need to...", options: ["type.", "click.", "load."], correct: 0 },
                    { q: "What is an ICON?", options: ["A space where you write the address.", "A button you click to do an action.", "A small picture that links to something."], correct: 2 },
                    { q: "The sentence 'The page _______ slowly' needs the correct Present Simple verb.", options: ["load", "loads", "loading"], correct: 1 },
                    { q: "The word BUTTON is a place you click to do an ________.", options: ["address", "action", "icon"], correct: 1 },
                ]
            },
            // --- TEST 2: Cyber Safety: Passwords and Secret Information ---
            {
                id: 'test2',
                title: 'Test 2: Cyber Safety: Passwords and Secret Information üîí',
                description: 'Read the text and answer the questions one by one.',
                text: 
                    "**Cyber Safety** is about staying safe in the Internet world. Your **password** is the most important thing‚Äîit is your **SECRET KEY** that lets you enter your accounts and platforms. The biggest risk is **Password Sharing**, which means giving your secret key to someone else, even a friend. The rule is simple: **NEVER** share your password with anyone. To make your account stronger, you can use **2-Step Login**; this requires your password and a second thing, usually a code sent to your phone. Another big danger is sharing **Secret Info**. This is information that tells people who you are in the real world, such as your full name, home address, or phone number. Sharing too much of this is called **Telling Too Much**. Before you give Secret Info, you must follow the **PROTECTION** rule: **Ask an adult**. Finally, many devices add a **Location Tag** to your photos, which says exactly where you are. Always turn this off.",
                questions: [
                    { q: "What does CYBER SAFETY mean?", options: ["Sharing your passwords with friends.", "Staying safe in the Internet world.", "Playing games on your phone."], correct: 1 },
                    { q: "What is your password?", options: ["Your SECRET KEY to enter your account.", "A possible danger or problem.", "A type of website address."], correct: 0 },
                    { q: "PASSWORD SHARING is the biggest risk. What does it mean?", options: ["Getting better things in a game.", "Giving your secret key to someone else.", "Changing your password often."], correct: 1 },
                    { q: "What is the simple rule for your password?", options: ["Tell only your best friend.", "NEVER tell your password to anyone.", "Write it in your group chat."], correct: 1 },
                    { q: "2-STEP LOGIN makes your account strong because you need two things. What are they?", options: ["A key and a code from your phone.", "A friend's password and your password.", "Your full name and home address."], correct: 0 },
                    { q: "SECRET INFO is information that can tell people what?", options: ["Your favorite game.", "Who you are in the real world.", "What kind of computer you have."], correct: 1 },
                    { q: "Which of these is an example of SECRET INFO?", options: ["Your full name.", "The name of your dog.", "The color of your shirt."], correct: 0 },
                    { q: "What does Telling Too Much mean?", options: ["Giving people more information than they need.", "Asking an adult for help.", "Taking a photo at your house."], correct: 0 },
                    { q: "What is the PROTECTION rule before giving Secret Info?", options: ["Post it in public chats.", "Ask an adult.", "Share it with your friend, Tom."], correct: 1 },
                    { q: "What is a Location Tag?", options: ["A note on your photo that says where you are.", "The full address of a website.", "A key that only one person should have."], correct: 0 },
                ]
            },
            // --- TEST 3: Cyber Safety: Fake Profiles and Trick Messages ---
            {
                id: 'test3',
                title: 'Test 3: Cyber Safety: Fake Profiles and Trick Messages üïµÔ∏è‚Äç‚ôÄÔ∏è',
                description: 'Read the text and answer the questions one by one.',
                text: 
                    "Sometimes, people use a **Fake Profile**, which is a false or untrue account, to trick or manipulate you. They might pretend to be a classmate or a famous person to get information. If you get a friend request that looks strange, you must **LOOK HARD** (check carefully) at the profile. If the profile has no shared friends, no real photos, or strange messages, you must **BLOCK** them to stay safe. Another big risk is the **Trick Message** (or phishing). This is a message that tries to fool you to steal your password or secret info. These messages often say the situation is **URGENT** (must be done now/quickly) to make you panic and click a link. When you get one, you must **Stop and Check** the sender's address. If the address is strange or official-looking but wrong, you must immediately **DELETE** the message. Never click the link!",
                questions: [
                    { q: "What is a FAKE PROFILE?", options: ["An account that uses 2-step login.", "A false or untrue account.", "A profile with many shared friends."], correct: 1 },
                    { q: "Why do people use a Fake Profile?", options: ["To give you a free game download.", "To trick or manipulate you.", "To help you get better things."], correct: 1 },
                    { q: "What should you do if a new friend request looks suspicious?", options: ["Look hard at the profile.", "Immediately share your photos.", "Agree to meet the person online."], correct: 0 },
                    { q: "What does LOOK HARD mean?", options: ["To look quickly.", "To check carefully.", "To be by yourself."], correct: 1 },
                    { q: "If a new friend request has no shared friends or photos, what should you do?", options: ["Add them.", "Block them.", "Ask them to meet."], correct: 1 },
                    { q: "What is a TRICK MESSAGE?", options: ["A message that helps you fix your account.", "A message that tries to fool you to steal your key/info.", "A friendly message from an official app store."], correct: 1 },
                    { q: "If you see the word URGENT in a message, what does it mean?", options: ["Something must be done now/quickly.", "You can check the sender's name later.", "The account will close in one year."], correct: 0 },
                    { q: "What is the first thing you should do when you get a 'Trick Message'?", options: ["Click the link quickly.", "Stop and check the sender's name/address.", "Ask the sender for your password."], correct: 1 },
                    { q: "If the sender's address in an urgent message is strange, you should...", options: ["click the link.", "reply quickly.", "DELETE the message."], correct: 2 },
                    { q: "What does DELETE mean?", options: ["To remove or take away a file or message.", "To check carefully.", "To believe that someone is honest."], correct: 0 },
                ]
            },
            // --- TEST 4: Cyber Safety: Cyberbullying and Bad Software/App Access ---
            {
                id: 'test4',
                title: 'Test 4: Cyberbullying and Bad Software/App Access üõë',
                description: 'Read the text and answer the questions one by one.',
                text: 
                    "**Cyberbullying** is a serious problem. It means using mean words or actions on a platform to hurt another person. If someone is cyberbullying you, the most important rule is **DO NOT REPLY**. The second step is to **SAVE THE PROOF** by taking a screenshot of the mean words. After saving the proof, you must **TELL AN ADULT** and block the bully. Another risk is **Computer Sickness** or **Malware**. This is bad software that can damage your phone or computer, or make your files disappear. You should only **DOWNLOAD** apps from **Official** stores (like the App Store) because they are real and approved by the company. When you install an app, it asks you to **GIVE ACCESS**. This means you permit the app to use your device's features, like your camera or **Contacts** (your list of people you know). If a simple app asks for strange access, you must **READ CAREFULLY** and **SAY NO**.",
                questions: [
                    { q: "CYBERBULLYING is using ________ to hurt someone online.", options: ["helpful words", "MEAN WORDS", "2-step login"], correct: 1 },
                    { q: "What is one protection step against cyberbullying?", options: ["Start a group chat attack.", "DO NOT REPLY to the mean words.", "Only tell your friend."], correct: 1 },
                    { q: "If someone is cyberbullying you, what does SAVE THE PROOF mean?", options: ["To share the mean words with other people.", "To take a picture (screenshot) of the screen.", "To keep your phone closed."], correct: 1 },
                    { q: "What should you do with the proof of cyberbullying?", options: ["Block the person and TELL AN ADULT.", "Delete the bad messages immediately.", "Wait until you feel alone."], correct: 0 },
                    { q: "COMPUTER SICKNESS (Malware) is a program that does what?", options: ["Downloads files to your device.", "Downloads only official games.", "Damages your device or makes files disappear."], correct: 2 },
                    { q: "You should ONLY DOWNLOAD from safe places like Official stores. What does Official mean?", options: ["Real and approved by the company.", "From a strange website.", "A free game download."], correct: 0 },
                    { q: "What does GIVE ACCESS mean?", options: ["You remove a file or message.", "You permit the app to use your device's features.", "You use your key and a phone code."], correct: 1 },
                    { q: "What is strange if a flashlight app asks for Contacts and Location?", options: ["It needs to use your camera.", "The app does not need this information to work.", "It helps you see your list of friends."], correct: 1 },
                    { q: "What is a list of people you know on your phone called?", options: ["Contacts.", "Fake Profiles.", "Location Tags."], correct: 0 },
                    { q: "What should you do before you GIVE ACCESS to an app?", options: ["Say yes quickly.", "READ CAREFULLY.", "Download a free game."], correct: 1 },
                ]
            }
        ];


        // --- STATE AND LOCAL STORAGE MANAGEMENT ---
        let state = {
            currentTestIndex: 0,
            currentQuestionIndex: 0,
            isReadingPhase: true,
            // Stores all votes: { 'test1-q0': { 'my-current-user': 1, 'sim1': 2, ... } }
            allVotes: {}, 
            // Stores whether a question has been checked (locally)
            questionStatus: tests.reduce((acc, test) => { acc[test.id] = {}; return acc; }, {}),
        };
        
        const quizContainer = document.getElementById('quiz-container');

        // Load votes and simulation data from local storage
        function loadData() {
            const storedVotes = localStorage.getItem('quizAllVotes');
            if (storedVotes) {
                state.allVotes = JSON.parse(storedVotes);
            } else {
                state.allVotes = {};
                // If no votes are stored (e.g., first run or after a reset), initialize the simulated votes
                initializeSimulatedVotes();
            }

            const storedState = localStorage.getItem('quizState');
            if (storedState) {
                const loadedState = JSON.parse(storedState);
                state.currentTestIndex = loadedState.currentTestIndex || 0;
                state.currentQuestionIndex = loadedState.currentQuestionIndex || 0;
                state.isReadingPhase = loadedState.isReadingPhase !== undefined ? loadedState.isReadingPhase : true;
                state.questionStatus = loadedState.questionStatus || state.questionStatus;
            }
        }

        // Save current votes and state to local storage
        function saveData() {
            localStorage.setItem('quizAllVotes', JSON.stringify(state.allVotes));
            localStorage.setItem('quizState', JSON.stringify({
                currentTestIndex: state.currentTestIndex,
                currentQuestionIndex: state.currentQuestionIndex,
                isReadingPhase: state.isReadingPhase,
                questionStatus: state.questionStatus
            }));
        }

        // Initialize random, persistent votes for the simulated users
        function initializeSimulatedVotes() {
            tests.forEach(test => {
                test.questions.forEach((qData, qIndex) => {
                    const key = `${test.id}-q${qIndex}`;
                    
                    // Only initialize the votes for this question if it doesn't exist.
                    if (!state.allVotes[key]) {
                        state.allVotes[key] = { [USER_ID]: undefined }; // Initialize current user's vote as undefined (0 votes)
                        
                        SIMULATED_USERS.forEach(simId => {
                            // Assign a random vote index (0, 1, or 2)
                            state.allVotes[key][simId] = Math.floor(Math.random() * qData.options.length);
                        });
                    }
                });
            });
            saveData();
        }


        // --- CORE QUIZ LOGIC ---

        // Initial setup function
        function initQuiz() {
            loadData();
            renderCurrentTest();
        }
        
        // Function to clear all local storage data and restart the quiz
        function resetAllData() {
            localStorage.clear();
            // Re-run initialization to generate new persistent simulated votes
            // This will make all displayed vote counts start at 0 before the sim votes are generated,
            // then the sim votes will be applied, so they'll only be 0 on a fresh load.
            window.location.reload(); 
        }

        // Renders the main structure for the current test (Reading Text + Question Area)
        function renderCurrentTest() {
            const currentTest = tests[state.currentTestIndex];
            
            // If starting a new test, reset to the first question and reading phase
            if (state.isReadingPhase || state.currentTestIndex !== tests.indexOf(currentTest)) {
                 state.currentQuestionIndex = 0;
                 state.isReadingPhase = true;
            }

            quizContainer.innerHTML = `
                <div id="test-card-${currentTest.id}" class="test-card bg-white p-6 sm:p-8 rounded-xl shadow-xl my-8 border-t-4 border-secondary-blue">
                    <h2 class="text-3xl font-bold text-gray-800 mb-4 pb-2 border-b border-gray-200">${currentTest.title}</h2>
                    
                    <!-- Reading Text Section -->
                    <div id="reading-section" class="reading-text bg-blue-50/70 p-4 sm:p-6 rounded-lg mb-8 text-gray-700 border-l-4 border-secondary-blue ${state.isReadingPhase ? '' : 'hidden'}">
                        <p class="font-bold text-xl mb-3 text-secondary-blue">Reading Text:</p>
                        <p class="whitespace-pre-wrap text-base">${currentTest.text}</p>
                        <button onclick="startQuestions()" class="mt-6 w-full px-6 py-3 bg-primary-green hover:bg-green-700 text-white font-bold rounded-lg shadow-md transition duration-200">
                            Start Questions
                        </button>
                    </div>

                    <!-- Question Section -->
                    <div id="question-section" class="${state.isReadingPhase ? 'hidden' : ''}">
                        <div id="question-content">
                            <!-- Question and options will be injected here -->
                        </div>
                        <div id="navigation-controls" class="mt-8 flex justify-between space-x-4">
                            <!-- Navigation buttons injected here -->
                        </div>
                    </div>

                    <!-- Result Box -->
                    <div id="${currentTest.id}-result" class="result-box mt-6 p-4 rounded-lg bg-secondary-blue/10 border border-secondary-blue/30 hidden">
                        <!-- Final results injected here -->
                    </div>
                </div>
            `;
            
            if (!state.isReadingPhase) {
                displayCurrentQuestion();
            }

            saveData();
        }

        // Hides reading text and shows the current question
        function startQuestions() {
            document.getElementById('reading-section').classList.add('hidden');
            document.getElementById('question-section').classList.remove('hidden');
            state.isReadingPhase = false;
            displayCurrentQuestion();
        }
        
        // Updates the current user's vote and re-renders
        function updateVote(qIndex, selectedValue) {
            const currentTest = tests[state.currentTestIndex];
            const key = `${currentTest.id}-q${qIndex}`;
            
            if (!state.allVotes[key]) {
                // Should not happen if initializeSimulatedVotes ran, but handle safely
                initializeSimulatedVotes();
                // Ensure new question key exists before setting vote
                if (!state.allVotes[key]) {
                    state.allVotes[key] = { [USER_ID]: undefined };
                }
            }
            
            // Record the current user's vote
            state.allVotes[key][USER_ID] = selectedValue;
            saveData();
            
            // Re-render to show the updated vote counts and majority
            displayCurrentQuestion();
        }

        // Renders the current question based on state.currentQuestionIndex
        function displayCurrentQuestion() {
            const currentTest = tests[state.currentTestIndex];
            const qData = currentTest.questions[state.currentQuestionIndex];
            const qIndex = state.currentQuestionIndex;
            const testId = currentTest.id;
            const totalQuestions = currentTest.questions.length;
            const key = `${testId}-q${qIndex}`;
            
            const questionContent = document.getElementById('question-content');
            const navigationControls = document.getElementById('navigation-controls');
            
            const currentQuestionVotes = state.allVotes[key] || {};
            
            // --- TALLY VOTES AND FIND MAJORITY ---
            const voteCounts = qData.options.map(() => 0);
            let maxVotes = -1;
            let majorityAnswerIndex = -1;
            let totalVotesCast = 0;
            
            Object.values(currentQuestionVotes).forEach(optionIndex => {
                if (optionIndex !== undefined && optionIndex !== null) {
                    voteCounts[optionIndex]++;
                    totalVotesCast++;
                    if (voteCounts[optionIndex] > maxVotes) {
                        maxVotes = voteCounts[optionIndex];
                        majorityAnswerIndex = optionIndex;
                    } 
                    // No tie-breaking needed, simply the one with the highest count
                }
            });

            const myVote = currentQuestionVotes[USER_ID];
            // Check if the question has been checked locally by the user
            const isChecked = state.questionStatus[testId] && state.questionStatus[testId][qIndex] !== undefined;
            const isCorrect = isChecked ? state.questionStatus[testId][qIndex] : undefined;

            // 1. Render Question Content
            questionContent.innerHTML = `
                <div class="question p-4 rounded-lg border border-gray-100" data-q-index="${qIndex}">
                    <p class="font-bold text-secondary-blue mb-1">Question ${qIndex + 1} of ${totalQuestions}</p>
                    <p class="font-semibold text-gray-900 mb-3 text-lg">${qData.q}</p>
                    <div class="options space-y-2">
                        ${qData.options.map((option, oIndex) => {
                            const inputName = `${testId}-q${qIndex}`;
                            const isVotedByMe = myVote === oIndex;
                            const isMajorityAnswer = oIndex === majorityAnswerIndex && maxVotes > 0;
                            const currentVoteCount = voteCounts[oIndex];

                            let labelClass = 'flex items-center p-3 rounded-md transition-colors duration-150';

                            // Highlight my vote (light blue background)
                            if (isVotedByMe) {
                                labelClass += ' bg-blue-100 font-medium';
                            }

                            // Highlight group majority choice (blue border) - THIS IS THE FINAL ANSWER VOTE
                            if (isMajorityAnswer) {
                                labelClass += ' border-2 border-secondary-blue shadow-md';
                            }
                            
                            // Highlight fixed correct answer if checked locally
                            if (isChecked) {
                                // Highlight the FIXED correct answer with green
                                if (oIndex === qData.correct) {
                                    labelClass += ' !bg-green-100 border-green-400';
                                }
                                // Highlight my INCORRECT vote with red
                                else if (isVotedByMe && oIndex !== qData.correct) {
                                     labelClass += ' !bg-red-200 border-red-500';
                                }
                            }

                            return `
                                <label class="question-label ${labelClass}" for="${inputName}-o${oIndex}">
                                    <input 
                                        type="radio" 
                                        id="${inputName}-o${oIndex}" 
                                        name="${inputName}" 
                                        value="${oIndex}" 
                                        ${isVotedByMe ? 'checked' : ''} 
                                        onchange="window.updateVote(${qIndex}, ${oIndex})"
                                        class="w-4 h-4 text-primary-green focus:ring-primary-green"
                                    >
                                    <span class="ml-3 text-gray-700">${option} 
                                        <span class="font-bold text-gray-500 ml-2">(${currentVoteCount} votes)</span>
                                    </span>
                                </label>
                            `;
                        }).join('')}
                    </div>
                </div>
                
                ${isChecked !== undefined ? `<p class="mt-4 text-sm font-medium ${isCorrect ? 'text-primary-green' : 'text-red-600'}">
                    ${isCorrect ? 'Your individual choice (fixed key) was Correct! Move to the next question.' : 'Your individual choice was Incorrect. The correct fixed answer is highlighted in green.'}
                </p>` : ''}
                
                <p class="mt-4 text-sm text-gray-500">
                    <span class="font-bold">Total Voters:</span> ${TOTAL_VOTERS}. <span class="font-bold">Group Answer:</span> Option ${majorityAnswerIndex !== -1 ? majorityAnswerIndex + 1 : 'N/A'} (Highlighted with blue border).
                </p>
            `;

            // 2. Render Navigation Controls
            const prevButton = `<button onclick="navigateQuestion(-1)" ${qIndex === 0 ? 'disabled' : ''} class="px-4 py-2 bg-gray-200 text-gray-700 font-bold rounded-lg transition duration-200 disabled:opacity-50">‚Üê Previous</button>`;
            
            let nextButton;
            if (qIndex < totalQuestions - 1) {
                // Next Question Button
                nextButton = `<button id="next-btn" onclick="checkAnswer(true)" class="px-6 py-3 bg-secondary-blue hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition duration-200">
                                Check My Answer & Next ‚Üí
                              </button>`;
            } else {
                // Finish Test Button
                nextButton = `<button onclick="showFinalResults()" class="px-6 py-3 bg-primary-green hover:bg-green-700 text-white font-bold rounded-lg shadow-md transition duration-200">
                                Finish Test and Score!
                              </button>`;
            }

            navigationControls.innerHTML = `
                ${prevButton}
                ${nextButton}
            `;

            // Scroll to the question content only on initial load
            questionContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // Handles checking the answer for the current question
        function checkAnswer(navigateOnSuccess = false) {
            const currentTest = tests[state.currentTestIndex];
            const qData = currentTest.questions[state.currentQuestionIndex];
            const qIndex = state.currentQuestionIndex;
            const testId = currentTest.id;

            const myVote = state.allVotes[`${testId}-q${qIndex}`][USER_ID];
            
            const resultBox = document.getElementById(`${testId}-result`);
            if (myVote === undefined || myVote === null) {
                resultBox.classList.remove('hidden');
                resultBox.innerHTML = '<p class="text-red-500 font-bold">Please select an answer (vote) before checking.</p>';
                resultBox.scrollIntoView({ behavior: 'smooth', block: 'start' });
                return;
            } else {
                resultBox.classList.add('hidden');
                resultBox.innerHTML = '';
            }
            
            // Check against the fixed correct answer
            const isCorrect = myVote === qData.correct;
            state.questionStatus[testId][qIndex] = isCorrect;
            saveData();
            
            // Re-render the current question to show fixed-key feedback
            displayCurrentQuestion();

            // Navigate if requested 
            if (navigateOnSuccess) {
                setTimeout(() => {
                    navigateQuestion(1);
                }, 500); 
            }
        }

        // Handles moving between questions
        function navigateQuestion(direction) {
            const currentTest = tests[state.currentTestIndex];
            const newIndex = state.currentQuestionIndex + direction;

            if (newIndex >= 0 && newIndex < currentTest.questions.length) {
                state.currentQuestionIndex = newIndex;
                displayCurrentQuestion();
            } else if (newIndex === currentTest.questions.length && direction === 1) {
                showFinalResults();
            }
            saveData();
        }

        // Calculates and displays the final score for the current test
        function showFinalResults() {
            const currentTest = tests[state.currentTestIndex];
            const testId = currentTest.id;
            let score = 0;
            const totalQuestions = currentTest.questions.length;
            
            // Recalculate score based on current user's vote against the fixed answer
            for (let i = 0; i < totalQuestions; i++) {
                const key = `${testId}-q${i}`;
                const userVote = state.allVotes[key] ? state.allVotes[key][USER_ID] : undefined;
                
                // Ensure a vote exists before checking correctness
                if (userVote !== undefined && userVote === currentTest.questions[i].correct) {
                     score++;
                     state.questionStatus[testId][i] = true;
                } else if (userVote !== undefined) {
                    state.questionStatus[testId][i] = false;
                }
            }
            saveData();


            // Display overall results
            const resultBox = document.getElementById(`${testId}-result`);
            const color = score >= totalQuestions * 0.7 ? 'primary-green' : 'red-500';
            const message = score >= totalQuestions * 0.7 ? "Great job! You passed this section based on the fixed answers." : "Keep studying! Your final score is low based on the fixed answers. Try again.";
            
            resultBox.innerHTML = `
                <h3 class="text-2xl font-bold text-gray-800 mb-2">Quiz Results:</h3>
                <p class="text-xl font-bold text-${color}">Score: ${score} / ${totalQuestions}</p>
                <p class="text-md text-gray-700 mt-3">${message}</p>
                
                <div class="mt-6 flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
                    <button onclick="navigateTest(1)" class="px-6 py-3 bg-secondary-blue hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition duration-200">
                        ${state.currentTestIndex < tests.length - 1 ? 'Go to Next Test' : 'Quiz Complete!'}
                    </button>
                    <button onclick="renderCurrentTest()" class="px-6 py-3 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-lg shadow-md transition duration-200">
                        Review Test 
                    </button>
                </div>
            `;
            resultBox.classList.remove('hidden');
            resultBox.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        // Handles navigation between different tests
        function navigateTest(direction) {
            const newIndex = state.currentTestIndex + direction;
            if (newIndex >= 0 && newIndex < tests.length) {
                state.currentTestIndex = newIndex;
                state.isReadingPhase = true;
                renderCurrentTest();
            } else if (newIndex === tests.length) {
                 quizContainer.innerHTML = `
                    <div class="test-card bg-white p-10 rounded-xl shadow-xl my-8 text-center">
                        <h2 class="text-4xl font-extrabold text-primary-green mb-4">Congratulations! üéâ</h2>
                        <p class="text-xl text-gray-700">You have completed all the A2 Technical English quizzes.</p>
                    </div>
                `;
            }
            saveData();
        }
        
        // Expose functions globally for HTML calls
        window.updateVote = updateVote;
        window.startQuestions = startQuestions;
        window.checkAnswer = checkAnswer;
        window.navigateQuestion = navigateQuestion;
        window.showFinalResults = showFinalResults;
        window.renderCurrentTest = renderCurrentTest;
        window.navigateTest = navigateTest;
        window.resetAllData = resetAllData; // Expose the new reset function

        // Initialize the app on load
        initQuiz();
    </script>
</body>
</html>
